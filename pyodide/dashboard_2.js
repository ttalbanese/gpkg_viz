importScripts("https://cdn.jsdelivr.net/pyodide/v0.27.5/full/pyodide.js");

function sendPatch(patch, buffers, msg_id) {
  self.postMessage({
    type: 'patch',
    patch: patch,
    buffers: buffers
  })
}

async function startApplication() {
  console.log("Loading pyodide!");
  self.postMessage({type: 'status', msg: 'Loading pyodide'})
  self.pyodide = await loadPyodide();
  self.pyodide.globals.set("sendPatch", sendPatch);
  console.log("Loaded!");
  await self.pyodide.loadPackage("micropip");
  const env_spec = ['https://cdn.holoviz.org/panel/wheels/bokeh-3.7.3-py3-none-any.whl', 'https://cdn.holoviz.org/panel/1.7.2/dist/wheels/panel-1.7.2-py3-none-any.whl', 'pyodide-http==0.2.1', 'colorcet', 'fiona', 'geopandas', 'holoviews', 'hvplot', 'numpy', 'pandas']
  for (const pkg of env_spec) {
    let pkg_name;
    if (pkg.endsWith('.whl')) {
      pkg_name = pkg.split('/').slice(-1)[0].split('-')[0]
    } else {
      pkg_name = pkg
    }
    self.postMessage({type: 'status', msg: `Installing ${pkg_name}`})
    try {
      await self.pyodide.runPythonAsync(`
        import micropip
        await micropip.install('${pkg}');
      `);
    } catch(e) {
      console.log(e)
      self.postMessage({
	type: 'status',
	msg: `Error while installing ${pkg_name}`
      });
    }
  }
  console.log("Packages loaded!");
  self.postMessage({type: 'status', msg: 'Executing code'})
  const code = `
  \nimport asyncio\n\nfrom panel.io.pyodide import init_doc, write_doc\n\ninit_doc()\n\n# gpkg_compare_dashboard.py\n\nimport os\nimport tempfile\nfrom collections import OrderedDict\n\nimport numpy as np\nimport pandas as pd\nimport geopandas as gpd\nimport fiona\n\nimport panel as pn\nimport holoviews as hv\nimport hvplot.pandas  # registers hvplot extension\nfrom bokeh.palettes import Category10, Category20_20\nfrom bokeh.io import curdoc as bokeh_curdoc\nimport colorcet as cc\n\n\n# --- Extensions & Theme ---\npn.extension("tabulator", design="bootstrap")  # Bootstrap design; light by default\nhv.extension("bokeh")\n\n# -------------------------\n# ---- Global Styling -----\n# -------------------------\nACCENT = "#2C7FB8"\nTITLE = "GeoPackage Table Comparator"\nSUBTITLE = "Upload multiple GeoPackages, select tables & common columns, and export a publication-ready scatter plot."\n\ntemplate = pn.template.FastListTemplate(\n    title=TITLE,\n    sidebar_width=600,\n    header_background=ACCENT,\n    site="",\n    main_max_width="1200px",\n    theme="default",\n    theme_toggle=True,\n    #header=[pn.pane.Markdown(f"### {SUBTITLE}")],\n)\n\npn.config.raw_css.append(\n    """\n.bk.panel-models-markdown h2, .bk.panel-models-markdown h3, .bk.panel-models-markdown h4 { margin-top: 0.2rem !important; }\n.bk.bk-input-group label { font-weight: 600; }\n.bk.bk-btn { font-weight: 600; }\n"""\n)\n\n# -------------------------\n# ---- Widgets -------------\n# -------------------------\nfile_input = pn.widgets.FileInput(\n    name="Upload GeoPackages", accept=".gpkg", multiple=True, width=320\n)\nclear_btn = pn.widgets.Button(\n    name="Clear Uploads", button_type="warning", icon="trash", width=160\n)\n\ntables_accordion = pn.Accordion(\n    name="Tables by GeoPackage", active=[], sizing_mode="stretch_width"\n)\n\nx_select = pn.widgets.Select(name="X-axis (numeric)", options=[], width=280)\ny_select = pn.widgets.Select(name="Y-axis (numeric)", options=[], width=280)\n\nalpha_slider = pn.widgets.FloatSlider(\n    name="Point alpha", start=0.2, end=1.0, step=0.05, value=1.0, width=280\n)\nsize_slider = pn.widgets.IntSlider(\n    name="Point size", start=3, end=100, step=1, value=50, width=280\n)\nlegend_toggle = pn.widgets.Checkbox(name="Show legend", value=True)\ngrid_toggle = pn.widgets.Checkbox(name="Show grid", value=True)\ntitle_input = pn.widgets.TextInput(\n    name="Plot title", placeholder="Optional plot title", width=320\n)\n\n# Hidden trigger to force plot updates on dynamic checkbox changes\nplot_trigger = pn.widgets.IntInput(name="plot trigger", value=0, visible=False)\n\n# --- Export controls: PNG is default ---\nexport_format = pn.widgets.RadioButtonGroup(\n    name="Export format",\n    options=["SVG", "PNG", "PDF"],\n    button_type="primary",\n    button_style="solid",\n    value="PNG",\n)\nexport_dpi = pn.widgets.IntSlider(\n    name="DPI (for PNG)", start=100, end=600, step=50, value=300, width=300\n)\n\nexport_btn = pn.widgets.FileDownload(\n    label="Download High-Resolution Figure",\n    button_type="success",\n    filename="scatter.png",\n    width=300,\n)\n\n# Diagnostics / status\ncommon_cols_md = pn.pane.Markdown("", sizing_mode="stretch_width")\npoints_count_md = pn.pane.Markdown("", sizing_mode="stretch_width")\nstatus_alert = pn.pane.Alert(\n    "", alert_type="info", visible=False, sizing_mode="stretch_width"\n)\n\n# -------------------------\n# ---- Data State ----------\n# -------------------------\nTMPDIR = tempfile.TemporaryDirectory(prefix="gpkg_compare_")\nGPKG_DATA = (\n    OrderedDict()\n)  # {gpkg_name: {"path": path, "layers": {layer_name: DataFrame}}}\n_accordion_checkboxes = OrderedDict()  # gpkg_name -> CheckBoxGroup\n\n\ndef make_palette(n):\n    if n <= 10:\n        pal = list(Category10[10])\n\n    else:\n        pal = list(Category20_20) + list(cc.glasbey[: max(0, n - 20)])\n    # print(pal)\n    return pal[:n]\n\n\n# -------------------------\n# ---- Scheduling helper (robust next tick) ----\n# -------------------------\ndef schedule_next_tick(func, delay_ms: int = 1000):\n    doc = None\n    try:\n        doc = pn.state.curdoc\n    except Exception:\n        doc = None\n    if doc is None:\n        try:\n            doc = bokeh_curdoc()\n        except Exception:\n            doc = None\n    try:\n        if doc and hasattr(doc, "add_next_tick_callback"):\n            doc.add_next_tick_callback(lambda: func())\n            return\n        if doc and hasattr(doc, "add_timeout_callback"):\n            doc.add_timeout_callback(lambda: func(), delay_ms)\n            return\n    except Exception:\n        pass\n    func()\n\n\n# -------------------------\n# ---- Helpers -------------\n# -------------------------\ndef bytes_to_tempfile(name, data):\n    suffix = os.path.splitext(name)[1] if "." in name else ".gpkg"\n    tf = tempfile.NamedTemporaryFile(delete=False, suffix=suffix, dir=TMPDIR.name)\n    tf.write(data)\n    tf.flush()\n    tf.close()\n    return tf.name\n\n\ndef load_gpkg_tables(gpkg_path):\n    """Read all layers (tables) and normalize column names to strings."""\n    table_map = OrderedDict()\n    layers = fiona.listlayers(gpkg_path)\n    for layer in layers:\n        try:\n            gdf = gpd.read_file(gpkg_path, layer=layer)\n            df = (\n                pd.DataFrame(gdf.drop(columns="geometry"))\n                if "geometry" in gdf.columns\n                else pd.DataFrame(gdf)\n            )\n            # --- CRITICAL FIX: standardize column labels to clean strings ---\n            df.columns = [str(c).strip() for c in df.columns]\n            table_map[layer] = df\n        except Exception as e:\n            print(f"Warning: could not read layer '{layer}' from {gpkg_path}: {e}")\n    return table_map\n\n\ndef gather_selected_tables():\n    selected = {}\n    for gpkg_name, chk in _accordion_checkboxes.items():\n        for layer in chk.value:\n            df = GPKG_DATA[gpkg_name]["layers"].get(layer)\n            if df is not None and not df.empty:\n                selected[(gpkg_name, layer)] = df\n    return selected\n\n\ndef _detect_numeric_columns(df: pd.DataFrame):\n    """Return columns considered numeric, with a coercion fallback for string numerics."""\n    numeric = []\n    for c in df.columns:\n        s = df[c]\n        if pd.api.types.is_numeric_dtype(s):\n            numeric.append(str(c))\n            continue\n        try:\n            coerced = pd.to_numeric(s, errors="coerce")\n            if coerced.notna().sum() >= max(5, 0.5 * len(coerced)):\n                numeric.append(str(c))\n        except Exception:\n            pass\n    return numeric\n\n\ndef numeric_common_columns(selected_tables):\n    if not selected_tables:\n        return []\n    numeric_sets = []\n    for _, df in selected_tables.items():\n        num_cols = set(_detect_numeric_columns(df))\n        numeric_sets.append(num_cols)\n    return sorted(\n        set.intersection(*numeric_sets) if numeric_sets else set(),\n        key=lambda x: x.lower(),\n    )\n\n\n# ------ Race-free updating of axis selectors ------\ndef update_column_selects(event=None):\n    selected = gather_selected_tables()\n    commons = numeric_common_columns(selected)  # list[str]\n    # print(commons)\n    # Preview (for diagnosis)\n    # if commons:\n    #     common_cols_md.object = "##### Common numeric columns\\n" + ", ".join(f"\`{c}\`" for c in commons)\n    #     common_cols_md.visible = True\n    # else:\n    #     common_cols_md.object = ""\n    #     common_cols_md.visible = False\n\n    # Update options immediately\n    x_select.options = commons\n    y_select.options = commons\n\n    # Set values next tick to avoid Select blank state\n    def _set_values():\n        if len(commons) > 0:\n            # Keep current choice if still valid, else pick first/second\n            x_select.value = x_select.value if x_select.value in commons else commons[0]\n\n            y_select.value = y_select.value if y_select.value in commons else commons[1]\n\n            status_alert.visible = False\n        else:\n            x_select.value = None\n            y_select.value = None\n            status_alert.object = (\n                "No common numeric columns across the selected tables."\n            )\n            status_alert.alert_type = "warning"\n            status_alert.visible = True\n\n    schedule_next_tick(_set_values, delay_ms=1000)\n\n\n# -------------------------\n# ---- Plot Data & Style ---\n# -------------------------\ndef build_plot_df(selected_tables, x_col, y_col):\n    rows = []\n    for (gpkg_name, layer), df in selected_tables.items():\n        # Columns were normalized to strings at load time, so this membership works now\n        if x_col in df.columns and y_col in df.columns:\n            sub = df[[x_col, y_col]].copy()\n            sub = sub.replace([np.inf, -np.inf], np.nan).dropna(subset=[x_col, y_col])\n            sub["group"] = f"{gpkg_name}::{layer}"\n            rows.append(sub)\n    return (\n        pd.concat(rows, axis=0, ignore_index=True)\n        if rows\n        else pd.DataFrame(columns=[x_col, y_col, "group"])\n    )\n\n\ndef _consistent_palette(groups):\n    pal = make_palette(len(groups))\n    return {g: pal[i] for i, g in enumerate(groups)}\n\n\ndef _empty_plot_frame(grid, title):\n    base = hv.Points([]).opts(\n        width=900,\n        height=600,\n        xlim=(0, 1),\n        ylim=(0, 1),\n        xlabel="X",\n        ylabel="Y",\n        show_grid=grid,\n        bgcolor="white",\n        fontsize={"title": 14, "labels": 13, "xticks": 11, "yticks": 11, "legend": 11},\n    )\n    txt = hv.Text(0.5, 0.5, "Select tables and X/Y\u2026").opts(\n        text_align="center", text_baseline="middle", fontsize=12\n    )\n    return (base * txt).opts(\n        hv.opts.Overlay(title=title or "Scatter Plot", bgcolor="white")\n    )\n\n\ndef make_hv_scatter(x, y, alpha, size, legend, grid, title, trigger):\n    """Build the scatter plot; bound to widgets so Panel knows dependencies."""\n    selected = gather_selected_tables()\n\n    if not selected:\n        points_count_md.object = ""\n        return _empty_plot_frame(grid, title)\n\n    xcol = x\n    ycol = y\n    if (not x or not y) or (x == y):\n        points_count_md.object = ""\n        return _empty_plot_frame(grid, title)\n\n    xcol = str(xcol)\n    ycol = str(ycol)\n\n    df = build_plot_df(selected, xcol, ycol)\n    if df.empty:\n        points_count_md.object = "##### Points plotted: 0"\n        return _empty_plot_frame(grid, title or f"{ycol} vs. {xcol}")\n\n    groups = sorted(df["group"].unique().tolist())\n    color_map = _consistent_palette(groups)\n\n    overlays = []\n    for g in groups:\n        sub = df[df["group"] == g]\n        sc = (\n            sub.hvplot.scatter(\n                x=xcol,\n                y=ycol,\n                color=color_map[g],\n                size=size,\n                alpha=alpha,\n                legend=True,\n                hover=True,\n                tools=["hover"],\n                xlabel=xcol,\n                ylabel=ycol,\n            )\n            .opts(muted_alpha=0.1)\n            .relabel(g)\n        )\n        overlays.append(sc)\n\n    # Update point count diagnostics\n    points_count_md.object = (\n        f"##### Points plotted: {len(df):,} across {len(groups)} group(s)"\n    )\n\n    overlay = hv.Overlay(overlays).opts(\n        hv.opts.Scatter(\n            show_grid=grid,\n            fontsize={\n                "title": 14,\n                "labels": 13,\n                "xticks": 11,\n                "yticks": 11,\n                "legend": 11,\n            },\n            padding=0.05,\n            default_tools=["pan", "wheel_zoom", "box_zoom", "reset", "save", "hover"],\n            active_tools=["wheel_zoom"],\n            line_alpha=0.0,\n            marker="circle",\n            bgcolor="white",\n        ),\n        hv.opts.Overlay(\n            width=900,\n            height=600,\n            legend_position="top_right",\n            show_legend=legend,\n            title=title if title else f"{ycol} vs. {xcol}",\n            bgcolor="white",\n        ),\n    )\n    return overlay\n\n\n# Bind to widget params + trigger (ensures updates)\nplot_panel = pn.bind(\n    make_hv_scatter,\n    x=x_select,\n    y=y_select,\n    alpha=alpha_slider,\n    size=size_slider,\n    legend=legend_toggle,\n    grid=grid_toggle,\n    title=title_input,\n    trigger=plot_trigger,\n)\n\n# Always-rendered plot area (so clipboard works too)\nplot_view = pn.pane.HoloViews(\n    plot_panel, sizing_mode="stretch_both", min_height=500, css_classes=["plot-area"]\n)\n\n\n# -------------------------\n# ---- Export -------------\n# -------------------------\ndef export_figure_callback():\n    pn.io.save.save_png(plot_view.object, 'test.png')\n    \n    # selected = gather_selected_tables()\n    # xcol, ycol = x_select.value, y_select.value\n    # if not xcol or not ycol:\n    #     raise pn.io.FileDownloadCallbackError(\n    #         "Nothing to export. Please select tables and X/Y columns."\n    #     )\n    # xcol = str(xcol)\n    # ycol = str(ycol)\n\n    # df = build_plot_df(selected, xcol, ycol)\n    # if df.empty:\n    #     raise pn.io.FileDownloadCallbackError(\n    #         "No data available for the selected X/Y across chosen tables."\n    #     )\n\n    # groups = sorted(df["group"].unique().tolist())\n    # color_map = _consistent_palette(groups)\n\n    # plt.style.use("seaborn-v0_8-whitegrid")\n    # fig, ax = plt.subplots(figsize=(9, 6), dpi=100)\n    # fig.patch.set_facecolor("white")\n    # ax.set_facecolor("white")\n\n    # for g in groups:\n    #     sub = df[df["group"] == g]\n    #     ax.scatter(\n    #         sub[xcol],\n    #         sub[ycol],\n    #         s=size_slider.value * 6,\n    #         alpha=alpha_slider.value,\n    #         c=color_map[g],\n    #         edgecolors="none",\n    #         label=g,\n    #     )\n\n    # ax.set_xlabel(xcol, fontsize=13, color="black")\n    # ax.set_ylabel(ycol, fontsize=13, color="black")\n    # if title_input.value:\n    #     ax.set_title(title_input.value, fontsize=14, pad=10, color="black")\n\n    # if legend_toggle.value:\n    #     ax.legend(\n    #         loc="center left",\n    #         bbox_to_anchor=(1.02, 0.5),\n    #         frameon=False,\n    #         fontsize=10,\n    #         title="Group",\n    #     )\n\n    # ax.xaxis.set_major_formatter(ScalarFormatter(useMathText=True))\n    # ax.yaxis.set_major_formatter(ScalarFormatter(useMathText=True))\n    # ax.tick_params(labelsize=11, colors="black")\n    # if not grid_toggle.value:\n    #     ax.grid(False)\n\n    # fmt = export_format.value.lower()\n    # buf = io.BytesIO()\n    # dpi = export_dpi.value if fmt == "png" else 300\n    # fig.tight_layout()\n    # fig.savefig(\n    #     buf,\n    #     format=fmt,\n    #     dpi=dpi,\n    #     bbox_inches="tight",\n    #     facecolor="white",\n    #     edgecolor="white",\n    # )\n    # plt.close(fig)\n    # buf.seek(0)\n    # return buf.getvalue()\n\n\ndef _update_export_filename(event=None):\n    export_btn.filename = f"scatter.{export_format.value.lower()}"\n\n\nexport_btn.callback = export_figure_callback\nexport_format.param.watch(_update_export_filename, "value")\n_update_export_filename()\n\n\n# -------------------------\n# ---- Accordion Build & Watchers ----\n# -------------------------\ndef _watch_table_selection(event):\n    update_column_selects()\n    plot_trigger.value += 1  # nudge the plot\n\n\ndef rebuild_tables_accordion():\n    _accordion_checkboxes.clear()\n    tables_accordion.clear()\n    for gpkg_name, meta in GPKG_DATA.items():\n        layer_names = list(meta["layers"].keys())\n        chk = pn.widgets.CheckBoxGroup(\n            name=gpkg_name, options=layer_names, inline=False, width=300\n        )\n        _accordion_checkboxes[gpkg_name] = chk\n        chk.param.watch(_watch_table_selection, "value")\n        title = f"\U0001f4e6 {gpkg_name} ({len(layer_names)} tables)"\n        tables_accordion.append((title, chk))\n    tables_accordion.active = [0] if len(tables_accordion.objects) else []\n\n\n# -------------------------\n# ---- Upload/Clear Callbacks ----\n# -------------------------\ndef _handle_uploaded_files(event=None):\n    pairs = []\n    \n    v = file_input.value\n    names = file_input.filename\n    if not v:\n        return\n    if isinstance(v, (list, tuple)):\n        if names is None:\n            names = [str(x) for x in range(len(v))]\n        for data, name in zip(v, names):\n            pairs.append((name, data))\n    else:\n        pairs.append((names, v))\n\n    added = []\n    for name, data in pairs:\n        if not name or not data or not name.lower().endswith(".gpkg"):\n            continue\n        path = bytes_to_tempfile(name, data)\n        tables = load_gpkg_tables(path)\n        if not tables:\n            continue\n        base = os.path.basename(name)\n        gpkg_key = base\n        i = 2\n        while gpkg_key in GPKG_DATA:\n            gpkg_key = f"{os.path.splitext(base)[0]}_{i}.gpkg"\n            i += 1\n        GPKG_DATA[gpkg_key] = {"path": path, "layers": tables}\n        added.append(gpkg_key)\n\n    if added:\n        rebuild_tables_accordion()\n        update_column_selects()\n        plot_trigger.value += 1\n        status_alert.object = f"Loaded {len(added)} GeoPackage(s): {', '.join(added)}"\n        status_alert.alert_type = "success"\n        status_alert.visible = True\n\n\ndef _clear_uploads(event=None):\n    GPKG_DATA.clear()\n    rebuild_tables_accordion()\n    x_select.options = []\n    y_select.options = []\n    x_select.value = None\n    y_select.value = None\n    plot_trigger.value += 1\n    status_alert.object = "Cleared all uploads."\n    status_alert.alert_type = "info"\n    status_alert.visible = True\n    common_cols_md.object = ""\n    common_cols_md.visible = False\n    points_count_md.object = ""\n\n\nfile_input.param.watch(_handle_uploaded_files, "value")\nclear_btn.on_click(_clear_uploads)\n\n# -------------------------\n# ---- Layout --------------\n# -------------------------\nsidebar = pn.Column(\n    "#### 1) Upload GeoPackages",\n    file_input,\n    pn.Row(clear_btn),\n    pn.layout.Divider(),\n    "#### 2) Choose tables",\n    tables_accordion,\n    pn.layout.Divider(),\n    "#### 3) X/Y columns",\n    x_select,\n    y_select,\n    common_cols_md,  # preview of common columns\n    points_count_md,  # points count (diagnostic)\n    pn.layout.Divider(),\n    "#### Plot options",\n    title_input,\n    alpha_slider,\n    size_slider,\n    pn.Row(legend_toggle, grid_toggle),\n    pn.layout.Divider(),\n    "#### Export",\n    export_format,\n    export_dpi,\n    export_btn,\n    sizing_mode="stretch_width",\n)\n\nmain = pn.Column(\n    status_alert,\n    pn.pane.Markdown("### Scatter Plot", styles={"font-weight": "600"}),\n    plot_view,\n    sizing_mode="stretch_both",\n)\n\ntemplate.sidebar[:] = [sidebar]\ntemplate.main[:] = [main]\n\n# Initial build\nrebuild_tables_accordion()\ntemplate.servable()\n\n\nawait write_doc()
  `

  try {
    const [docs_json, render_items, root_ids] = await self.pyodide.runPythonAsync(code)
    self.postMessage({
      type: 'render',
      docs_json: docs_json,
      render_items: render_items,
      root_ids: root_ids
    })
  } catch(e) {
    const traceback = `${e}`
    const tblines = traceback.split('\n')
    self.postMessage({
      type: 'status',
      msg: tblines[tblines.length-2]
    });
    throw e
  }
}

self.onmessage = async (event) => {
  const msg = event.data
  if (msg.type === 'rendered') {
    self.pyodide.runPythonAsync(`
    from panel.io.state import state
    from panel.io.pyodide import _link_docs_worker

    _link_docs_worker(state.curdoc, sendPatch, setter='js')
    `)
  } else if (msg.type === 'patch') {
    self.pyodide.globals.set('patch', msg.patch)
    self.pyodide.runPythonAsync(`
    from panel.io.pyodide import _convert_json_patch
    state.curdoc.apply_json_patch(_convert_json_patch(patch), setter='js')
    `)
    self.postMessage({type: 'idle'})
  } else if (msg.type === 'location') {
    self.pyodide.globals.set('location', msg.location)
    self.pyodide.runPythonAsync(`
    import json
    from panel.io.state import state
    from panel.util import edit_readonly
    if state.location:
        loc_data = json.loads(location)
        with edit_readonly(state.location):
            state.location.param.update({
                k: v for k, v in loc_data.items() if k in state.location.param
            })
    `)
  }
}

startApplication()